# 基于事件的并发

## 事件循环

### 基于事件的并发

- 等待某事发生，当它发生时检查事件类型，然后做少量的相应工作
- 处理程序在处理一个事件时，它是系统中发生的唯一的活动，因此，调度就是决定接下来处理哪个事件，这种调度是显示控制

### 重要APIselect()/poll()

- 它可以让你检查描述符是否可以读取和写入
- 注意超时参数，一种常见的技术是将超时设置为零

### 使用单个CPU和基于事件的应用程序，并发程序中发现的问题不再存在

- 请勿阻塞基于事件的服务器，以确保基于事件的服务器可以对任务调度进行细粒度控制

## 不允许阻塞调用

### open()和read()等系统调用将会阻塞掉线程（进程），当事件循环阻塞时，系统处于闲置状态，因此是潜在的巨大的资源浪费

### 异步I/O

- 这些接口使程序能够发出I/O请求，并在I/O完成之前立即将控制权返回给调用者，另外的接口让程序能够确定各种I/O是否已经完成

## 状态管理

### 手工栈管理

- 当事件处理程序发出异步I/O时，它必须打包一些程序状态，以便下一个事件处理程序在I/O最终完成时使用，这导致代码复杂
- 在某些数据结构中记录完成处理该事件需要的信息，当事件发生时，查找所需信息并处理事件

## 其余问题

* 利用多个CPU事件服务器必须并行运行多个事件处理程序，同步问题接踵而来

* 不能很好的与某些类型的系统活动集成

* 异步I/O使用的复杂性

