# 进程的调度

## 调度初探

### 评价指标：周转时间=完成时间-到达时间

### 先入先出FIFO

- 简单易实现
- 护航效应：一些耗时较少的潜在资源消费者被排在重量级消费者之后

### 最短任务优先SJF

- 对同时到达的情况是最优解
- 对不同时到达的情况束手无策

### 最短完成时间优先STCF

- 向SJF中引入抢占，每当新任务到达时，先确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作

### 新评价指标：响应时间=首次运行时间-到达时间

- 应对分时系统交互性需要

### 轮转RR

- 在一个时间片内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束
- 时间片越短响应时间越短，但是过短的时间片带来上下文切换开销影响增大的问题，需要摊销上下文切换的成本
- RR的周转时间指标很差，这需要权衡周转时间与响应时间

> 程序运行时在CPU高速缓存、TLB、分支预测器和其他片上硬件中建立了大量的状态，切换到另一个工作会导致此状态被刷新，且与当前运行的作业相关的新状态被引入

### 结合I/O

- 引入重叠操作，最大限度地提高系统的利用率
- 调度程序在工作发起I/O以及I/O完成时做出决定，以进行重叠操作

## 多级反馈队列MLFQ

### 针对问题

- 优化周转时间，而操作系统通常不知道工作要运行多久
- 给交互用户良好的交互体验，需要降低响应时间

### 基本规则

- MLFQ中有许多独立的队列，每个队列有不同的优先级，任何时刻一个工作只能在一个队列之中，MLFQ总是优先执行较高优先级的工作
- 规则1：如果A的优先级 > B的优先级，运行A
- 规则2：如果A的优先级 = B的优先级，轮转运行A和B
- MLFQ关键是如何给工作设置优先级

### 如何改变优先级

- 规则3：工作进入系统时，放在最高优先级（最上层队列）
- 规则4a：工作用完整个时间片后，降低其优先级（移入下一个队列）
- 规则4b：如果工作在其时间片以内主动释放CPU，则优先级不变
- 思想
  - 不知道工作是短工作还是长工作时，先假设其是短，并赋予其最高优先级，如果是短工作则很快执行，如果是长工作则将慢慢被降低优先级

- 缺点

  - 饥饿问题：如果太多交互性工作就会不断占用CPU，导致长工作（低优先级）永远无法得到CPU
  - 愚弄调度程序：进程在时间片用完之前调用一个IO释放CPU以保持高优先级
  - 一个程序可能在不同的时间表现不同：一个计算密集的进程可能在某段时间表现为一个交互性进程，但其无法获得其他交互性工作的待遇

### 提升优先级

- 针对饥饿问题，提出新规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列

	- 解决了饥饿问题和计算密集工作变成交互型时的问题

- 巫毒常量：S如何设置

	- S过长会导致饥饿
	- S过短会导致交互型工作得不到合适的CPU时间比例

### 更好的计时方式

- 改写规则4：一旦工作用完了其在某一层中的时间配额（无论中途主动放弃了多少次CPU），就降低其优先级
- 解决愚弄调度程序问题

### MLFQ调优问题

- 可变时间片长度
- 提供一组表来决定进程在其生命周期中如何调整优先级
- 采用数学公式调整优先级

### 小结

- 规则1：如果A的优先级 > B的优先级，运行A
- 规则2：如果A的优先级 = B的优先级，轮转运行A和B
- 规则3：工作进入系统时，放在最高优先级（最上层队列）
- 规则4：一旦工作用完了其在某一层中的时间配额（无论中途主动放弃了多少次CPU），就降低其优先级
- 规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列

## 比例份额

### 基本思想

- 每隔一段时间举行一次彩票抽奖，以确定接下来应该运行哪个进程
- 关键问题：如何按比例分配CPU
- 利用随机性

	- 随即方法常常可以避免奇怪的边角情况
	- 随即方法很轻量，几乎不需要记录任何状态
	- 随即方法很快

### 彩票机制

- 彩票货币概念：允许一组彩票的用户以它们喜欢的某种货币将彩票分给自己的不同工作，之后操作系统将其兑换成全局彩票
- 彩票转让机制：通过转染，一个进程可以临时将自己的彩票交给另一个进程
- 彩票通胀机制：一个进程可以临时提升或降低自己拥有的彩票数量，可以用于进程互相信任的环境，进程以此方式告诉操作系统自己需要更多的运行时间

### 优缺点

- 实现简单，只需要随机数生成器及计算器即可
- 在工作长度很短时公平性将很差
- 如何分配彩票是很棘手的问题

## 多处理器调度

### 多处理器架构

* 与单CPU的基本区别：对硬件缓存的使用以及多处理器之间共享数据的方式
* 单CPU中存在多级缓存，缓存基于时间局部性以及空间局部性，硬件系统因此可以很好的预测哪些数据可以放入缓存
* 多处理器情况下缓存要复杂的多，缓存一致性问题。硬件提供基本解决方案：通过监控内存访问，硬件可以保证获得正确的数据，并保证共享内存的唯一性，如总线窥探

### 同步问题

* 跨CPU访问共享数据或数据结构时，需要使用互斥原语才能保证正确性
* 随着CPU数量增加，访问同步共享的数据结构会变得很慢

### 缓存亲和度问题

* 进程在不同CPU上切换运行需要重新加载数据使得性能变慢

### 单队列调度

* 简单地复用单处理器调度的基本架构，将所有需要调度的工作放入一个单独的队列中SQMS
* 优点是简单不需要太多修改
* 缺点
  * 缺乏可扩展性：需要加锁保证原子性，使得性能受到锁的影响
  * 缓存亲和性：每个工作在不同CPU之间转移使得缓存亲和无从谈起
  * 引入一些亲和度机制，尽可能让进程在同一个CPU上运行，保持一些工作的亲和度的同时，可能需要牺牲其他工作的亲和度来实现负载均衡

### 多队列调度

* 多队列多处理器调度MQMS包含多个调度队列，每个队列可以使用不同的调度规则。当一个工作进入系统后，系统依照一些启发性规则将其放入某个调度队列。
* 避免单队列方法中由于数据共享及同步带来的问题，天生具有可扩展性和良好的缓存亲和度
* 负载不均问题：可能出现一个CPU空闲另一个CPU运行好几个线程的情况
* 为了实现负载均衡，进行跨CPU迁移，通过工作窃取（工作量较少的队列不定期地偷看别的队列是否比自己工作多）来不断发起迁移来均衡负载。

### Linux多处理器调度

* O(1)调度程序：多队列+MLFQ
* 完全公平调度程序CFS：多队列+比例调度
* BF调度程序BFS：单队列+基于比例调度的”最早最合适虚拟截止时间优先算法“



