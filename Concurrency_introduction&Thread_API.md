# 并发介绍与线程API

## 多线程

### 多线程程序

- 经典观点是一个程序只有一个执行点，但多线程程序会有多个执行点（多个程序计数器，每个都用于取指执行），每个线程类似于独立的进程，只是它们共享地址空间，从而能够访问相同的数据

- 单线程与多线程的地址空间

  

### 上下文切换

- 线程间上下文切换类似于进程间切换，将线程状态保存到线程控制块TCB(thread control block)中，与进程不同的是地址空间保持不变，即不需要切换当前使用的页表

### 线程创建

- ```c++
  #include <pthread.h>
  
  pthread_create(
          pthread_t* thread,
          const pthread_attr_t* attr,
          void* (*start_routine)(void*),
          void* arg
      );
  ```


### 线程完成

- 创建线程后，调用pthread_join()函数来等待线程完成

### 共享数据

- 多个线程同时访问共享数据时会引发错误

## 不可控调度引发的问题

### 场景：
线程1运行并进入一段代码区域时，系统时钟终端发生，操作系统将当前正在运行的线程的状态保存到线程的TCB，线程2被选中运行，并进入同一段代码，执行完指令后再次进行上下文切换，线程1恢复运行，继续被打断的指令。

### 竞态条件：

结果取决于代码的时间执行，每次运行的结果是不确定的

### 临界区：

由于执行这段代码的多个线程可能导致竞争状态，因此我们将此段代码成为临界区。临界区是访问共享变量的代码片段，一定不能由多个线程同时执行

### 互斥：

为了避免出现竞态条件以及不确定性，线程应该使用某种互斥原语，这样可以保证只有一个线程进入临界区。

### 锁

- 通过锁来提供互斥进入临界区的函数

- ```c++
  int pthread_mutex_lock(pthread_mutex_t* mutex);
  int pthread_mutex_unlock(pthread_mutex_t* mutex);
  ```

- 初始化

  ```c++
  pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
  pthread_mutex_init(&lock, NULL);
  ```

## 原子性愿望

解决不确定性问题的一种途径是拥有更强大的指令，单步就能完成要做的事，从而消除不合时宜的中断的可能性

原子方式执行：作为一个单元运行，全部或没有运行，没有中间状态

要求硬件提供一些有用的指令，可以在这些指令上构建一个通用的集合，即同步原语

## 等待另一个线程

另一种线程间交互的方式，即一个线程在继续之前必须等待另一个线程完成某些操作

### 条件变量

- ```c++
  int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex); //等待条件变量
  int pthread_cond_signal(pthread_cond_t* cond); //发送条件变量信号
  ```

## 线程API指导

### 保持简洁

- 复杂的线程交互容易产生缺陷

### 让线程交互减到最少

### 初始化锁和条件变量

- 未初始化的代码又是工作正常，但大多数时候会产生奇怪的结果

### 检查返回值

### 注意传给线程的参数和返回值

- 具体来说，如果传递在栈上分配的变量的引用，就是在犯错

### 每个线程都有自己的栈

- 记住每一个线程都有自己的栈。因此，线程局部变量应该是线程私有的，其他线程不应该访问。线程之间共享数据，值要在堆（heap）或者其他全局可访问的位置。

### 线程之间总是通过条件变量发送信号

- 切记不要用标记变量来同步

### 多查手册

